<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tree Structure Visualization</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        h1, h2 {
            color: #333;
        }
        .example {
            margin-bottom: 30px;
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        canvas {
            display: block;
            margin: 0 auto;
            border: 1px solid #ddd;
            background-color: white;
        }
        .controls {
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .controls label {
            margin-right: 10px;
            font-weight: bold;
        }
        select {
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #ccc;
            background-color: white;
            font-size: 14px;
            cursor: pointer;
        }
        select:focus {
            outline: none;
            border-color: #3498db;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Tree Structure Visualization</h1>
        
        <div class="example">
            <h2>Example 1: Binary Tree</h2>
            <div class="controls">
                <label for="layout1">Layout Strategy:</label>
                <select id="layout1" onchange="changeLayout(0, this.value)">
                    <option value="maxwidth">Maximum Width</option>
                    <option value="ltr">Squish Left-to-Right</option>
                    <option value="rtl">Squish Right-to-Left</option>
                    <option value="contour">Contour Method</option>
                </select>
            </div>
            <canvas id="canvas1" width="800" height="400"></canvas>
        </div>
        
        <div class="example">
            <h2>Example 2: General N-ary Tree</h2>
            <div class="controls">
                <label for="layout2">Layout Strategy:</label>
                <select id="layout2" onchange="changeLayout(1, this.value)">
                    <option value="maxwidth">Maximum Width</option>
                    <option value="ltr">Squish Left-to-Right</option>
                    <option value="rtl">Squish Right-to-Left</option>
                    <option value="contour">Contour Method</option>
                </select>
            </div>
            <canvas id="canvas2" width="800" height="400"></canvas>
        </div>
        
        <div class="example">
            <h2>Example 3: File System Tree</h2>
            <div class="controls">
                <label for="layout3">Layout Strategy:</label>
                <select id="layout3" onchange="changeLayout(2, this.value)">
                    <option value="maxwidth">Maximum Width</option>
                    <option value="ltr">Squish Left-to-Right</option>
                    <option value="rtl">Squish Right-to-Left</option>
                    <option value="contour">Contour Method</option>
                </select>
            </div>
            <canvas id="canvas3" width="800" height="500"></canvas>
        </div>
    </div>

    <script>
        // Tree node class
        class TreeNode {
            constructor(value, label = null) {
                this.value = value;
                this.label = label || value.toString();
                this.children = [];
                this.width = 0; // Store required width
                this.subtreeWidth = 0; // Width of entire subtree
                this.leftExtent = 0; // Left extent of subtree
                this.rightExtent = 0; // Right extent of subtree
                this.leftContour = []; // Left contour at each level
                this.rightContour = []; // Right contour at each level
                this.mod = 0; // Modifier for shifting subtrees
            }
            
            addChild(child) {
                this.children.push(child);
                return child;
            }
        }
        
        // Example 1: Binary Tree
        function createBinaryTree() {
            const root = new TreeNode(1);
            
            const node2 = root.addChild(new TreeNode(2));
            const node3 = root.addChild(new TreeNode(3));
            
            node2.addChild(new TreeNode(4));
            node2.addChild(new TreeNode(5));
            
            node3.addChild(new TreeNode(6));
            node3.addChild(new TreeNode(7));
            
            return root;
        }
        
        // Example 2: General N-ary Tree
        function createNaryTree() {
            const root = new TreeNode("Root");
            
            const nodeA = root.addChild(new TreeNode("A"));
            const nodeB = root.addChild(new TreeNode("B"));
            const nodeC = root.addChild(new TreeNode("C"));
            
            nodeA.addChild(new TreeNode("A1"));
            nodeA.addChild(new TreeNode("A2"));
            nodeA.addChild(new TreeNode("A3"));
            
            nodeB.addChild(new TreeNode("B1"));
            nodeB.addChild(new TreeNode("B2"));
            
            const nodeC1 = nodeC.addChild(new TreeNode("C1"));
            nodeC.addChild(new TreeNode("C2"));
            nodeC.addChild(new TreeNode("C3"));
            nodeC.addChild(new TreeNode("C4"));
            
            nodeC1.addChild(new TreeNode("C1.1"));
            nodeC1.addChild(new TreeNode("C1.2"));
            
            return root;
        }
        
        // Example 3: File System Tree
        function createFileSystemTree() {
            const root = new TreeNode("/", "Root Directory");
            
            const home = root.addChild(new TreeNode("home", "home"));
            const etc = root.addChild(new TreeNode("etc", "etc"));
            const var_ = root.addChild(new TreeNode("var", "var"));
            
            const user1 = home.addChild(new TreeNode("user1", "user1"));
            const user2 = home.addChild(new TreeNode("user2", "user2"));
            
            user1.addChild(new TreeNode("documents", "documents"));
            user1.addChild(new TreeNode("pictures", "pictures"));
            const downloads = user1.addChild(new TreeNode("downloads", "downloads"));
            
            user2.addChild(new TreeNode("projects", "projects"));
            const music = user2.addChild(new TreeNode("music", "music"));
            
            downloads.addChild(new TreeNode("file1.pdf", "file1.pdf"));
            downloads.addChild(new TreeNode("file2.jpg", "file2.jpg"));
            
            music.addChild(new TreeNode("song1.mp3", "song1.mp3"));
            music.addChild(new TreeNode("song2.mp3", "song2.mp3"));
            music.addChild(new TreeNode("song3.mp3", "song3.mp3"));
            
            etc.addChild(new TreeNode("config", "config"));
            etc.addChild(new TreeNode("hosts", "hosts"));
            
            var_.addChild(new TreeNode("log", "log"));
            var_.addChild(new TreeNode("tmp", "tmp"));
            
            return root;
        }
        
        // Create the tree data structures
        const trees = [
            createBinaryTree(),
            createNaryTree(),
            createFileSystemTree()
        ];
        
        // Get canvas contexts
        const canvases = [
            document.getElementById('canvas1'),
            document.getElementById('canvas2'),
            document.getElementById('canvas3')
        ];
        
        const contexts = canvases.map(canvas => canvas.getContext('2d'));
        
        // Tree drawing configuration
        const config = [
            { nodeRadius: 20, levelHeight: 60, nodeColor: '#3498db', textColor: 'white', lineColor: '#7f8c8d', nodeSpacing: 50 },
            { nodeRadius: 25, levelHeight: 70, nodeColor: '#2ecc71', textColor: 'white', lineColor: '#7f8c8d', nodeSpacing: 60 },
            { nodeRadius: 30, levelHeight: 80, nodeColor: '#e74c3c', textColor: 'white', lineColor: '#7f8c8d', nodeSpacing: 70 }
        ];
        
        // Track layout strategies
        const layoutStrategies = ['maxwidth', 'maxwidth', 'maxwidth'];
        
        // Change layout strategy
        function changeLayout(index, strategy) {
            layoutStrategies[index] = strategy;
            drawTree(index);
        }
        
        // Calculate contours for each subtree
        function calculateContours(node, level, cfg) {
            node.leftContour = [];
            node.rightContour = [];
            
            node.leftContour[level] = -cfg.nodeRadius;
            node.rightContour[level] = cfg.nodeRadius;
            
            if (node.children.length === 0) {
                return { width: cfg.nodeRadius * 2, height: 1 };
            }
            
            const childStats = [];
            for (const child of node.children) {
                childStats.push(calculateContours(child, 0, cfg));
            }
            
            const maxChildHeight = Math.max(...childStats.map(s => s.height));
            
            for (let i = 1; i <= maxChildHeight; i++) {
                node.leftContour[level + i] = Infinity;
                node.rightContour[level + i] = -Infinity;
            }
            
            for (let i = 0; i < node.children.length; i++) {
                const child = node.children[i];
                
                for (let j = 0; j < child.leftContour.length; j++) {
                    const leftPos = child._x - node._x + child.leftContour[j];
                    const rightPos = child._x - node._x + child.rightContour[j];
                    
                    node.leftContour[level + j + 1] = Math.min(
                        node.leftContour[level + j + 1], 
                        leftPos
                    );
                    node.rightContour[level + j + 1] = Math.max(
                        node.rightContour[level + j + 1], 
                        rightPos
                    );
                }
            }
            
            const width = Math.max(...node.rightContour) - Math.min(...node.leftContour);
            const height = maxChildHeight + 1;
            
            return { width, height };
        }
        
        // Get the minimum distance needed to separate two subtrees without overlap
        function getMinimumSeparation(leftNode, rightNode, levelHeight, cfg) {
            let minDistance = 0;
            
            const maxLevel = Math.max(
                leftNode.rightContour.length,
                rightNode.leftContour.length
            );
            
            for (let level = 0; level < maxLevel; level++) {
                if (level < leftNode.rightContour.length && level < rightNode.leftContour.length) {
                    const gap = leftNode.rightContour[level] - rightNode.leftContour[level];
                    minDistance = Math.max(minDistance, -gap + cfg.nodeRadius);
                }
            }
            
            return minDistance + cfg.nodeRadius * 2;
        }
        
        // Position nodes using contours to prevent any overlaps
        function positionNodesContour(node, x, y, level, levelHeight, cfg) {
            node._x = x;
            node._y = y;
            
            if (node.children.length === 0) return;
            
            for (const child of node.children) {
                positionNodesContour(child, x, y + levelHeight, level + 1, levelHeight, cfg);
            }
            
            for (const child of node.children) {
                calculateContours(child, 0, cfg);
            }
            
            let currentX = x;
            node.children[0]._x = currentX;
            
            for (let i = 1; i < node.children.length; i++) {
                const leftSubtree = node.children[i - 1];
                const rightSubtree = node.children[i];
                
                const separation = getMinimumSeparation(leftSubtree, rightSubtree, levelHeight, cfg);
                
                currentX = leftSubtree._x + separation;
                rightSubtree._x = currentX;
            }
            
            if (node.children.length > 1) {
                const leftmost = node.children[0]._x;
                const rightmost = node.children[node.children.length - 1]._x;
                node._x = (leftmost + rightmost) / 2;
            }
        }
        
        // Improved version of left-to-right squishing
        function improvedSquishLTR(node, x, y, level, levelHeight, cfg) {
            node._x = x;
            node._y = y;
            
            if (node.children.length === 0) {
                node.subtreeWidth = cfg.nodeRadius * 2;
                return;
            }
            
            let totalWidth = 0;
            for (let i = 0; i < node.children.length; i++) {
                const child = node.children[i];
                improvedSquishLTR(child, 0, y + levelHeight, level + 1, levelHeight, cfg);
                totalWidth += child.subtreeWidth;
            }
            
            totalWidth += (node.children.length - 1) * cfg.nodeRadius;
            
            let startX = x - totalWidth / 2;
            
            for (let i = 0; i < node.children.length; i++) {
                const child = node.children[i];
                child._x = startX + child.subtreeWidth / 2;
                startX += child.subtreeWidth + cfg.nodeRadius;
            }
            
            node.subtreeWidth = totalWidth;
        }
        
        // Improved version of right-to-left squishing
        function improvedSquishRTL(node, x, y, level, levelHeight, cfg) {
            node._x = x;
            node._y = y;
            
            if (node.children.length === 0) {
                node.subtreeWidth = cfg.nodeRadius * 2;
                return;
            }
            
            let totalWidth = 0;
            for (let i = node.children.length - 1; i >= 0; i--) {
                const child = node.children[i];
                improvedSquishRTL(child, 0, y + levelHeight, level + 1, levelHeight, cfg);
                totalWidth += child.subtreeWidth;
            }
            
            totalWidth += (node.children.length - 1) * cfg.nodeRadius;
            
            let startX = x + totalWidth / 2;
            
            for (let i = 0; i < node.children.length; i++) {
                const child = node.children[i];
                child._x = startX - child.subtreeWidth / 2;
                startX -= (child.subtreeWidth + cfg.nodeRadius);
            }
            
            node.subtreeWidth = totalWidth;
        }
        
        // Calculate the width needed for each subtree using max width approach
        function calculateSubtreeWidths(node, cfg) {
            if (node.children.length === 0) {
                node.width = cfg.nodeSpacing;
                return node.width;
            }
            
            let totalChildWidth = 0;
            for (const child of node.children) {
                totalChildWidth += calculateSubtreeWidths(child, cfg);
            }
            
            node.width = Math.max(totalChildWidth, cfg.nodeSpacing);
            return node.width;
        }
        
        // Position nodes using pre-calculated widths (max width approach)
        function positionNodesMaxWidth(node, x, y, level, levelHeight) {
            node._x = x;
            node._y = y;
            
            if (node.children.length > 0) {
                let currentX = x - (node.width / 2);
                
                for (const child of node.children) {
                    const childX = currentX + (child.width / 2);
                    positionNodesMaxWidth(child, childX, y + levelHeight, level, levelHeight);
                    currentX += child.width;
                }
            }
        }
        
        // Count tree levels
        function countLevels(node, level = 0) {
            let maxLevel = level;
            for (const child of node.children) {
                maxLevel = Math.max(maxLevel, countLevels(child, level + 1));
            }
            return maxLevel;
        }
        
        // Draw a node
        function drawNode(ctx, node, cfg, scale = 1) {
            const radius = cfg.nodeRadius * scale;
            
            node.children.forEach(child => {
                ctx.beginPath();
                ctx.moveTo(node._x, node._y);
                ctx.lineTo(child._x, child._y);
                ctx.strokeStyle = cfg.lineColor;
                ctx.lineWidth = 2 * scale;
                ctx.stroke();
            });
            
            ctx.beginPath();
            ctx.arc(node._x, node._y, radius, 0, Math.PI * 2);
            ctx.fillStyle = cfg.nodeColor;
            ctx.fill();
            
            ctx.fillStyle = cfg.textColor;
            ctx.font = `${12 * scale}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            let displayText = node.label;
            const textWidth = ctx.measureText(displayText).width;
            if (textWidth > radius * 1.8) {
                displayText = displayText.slice(0, 5) + '...';
            }
            
            ctx.fillText(displayText, node._x, node._y);
            
            node.children.forEach(child => drawNode(ctx, child, cfg, scale));
        }
        
        // Calculate tree dimensions
        function calculateTreeDimensions(node) {
            const nodeDims = {
                minX: node._x,
                maxX: node._x,
                minY: node._y,
                maxY: node._y
            };
            
            if (node.children.length === 0) return nodeDims;
            
            for (const child of node.children) {
                const childDims = calculateTreeDimensions(child);
                nodeDims.minX = Math.min(nodeDims.minX, childDims.minX);
                nodeDims.maxX = Math.max(nodeDims.maxX, childDims.maxX);
                nodeDims.maxY = Math.max(nodeDims.maxY, childDims.maxY);
            }
            
            return nodeDims;
        }
        
        // Draw a tree
        function drawTree(index) {
            const ctx = contexts[index];
            const canvas = canvases[index];
            const tree = trees[index];
            const cfg = config[index];
            const layoutStrategy = layoutStrategies[index];
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const traverseAndReset = (node) => {
                delete node._x;
                delete node._y;
                node.width = 0;
                node.subtreeWidth = 0;
                node.leftExtent = 0;
                node.rightExtent = 0;
                node.leftContour = [];
                node.rightContour = [];
                node.children.forEach(traverseAndReset);
            };
            traverseAndReset(tree);
            
            const maxLevel = countLevels(tree);
            
            const padding = 60;
            const levelHeight = (canvas.height - padding * 2) / (maxLevel + 1);
            
            if (layoutStrategy === 'maxwidth') {
                calculateSubtreeWidths(tree, cfg);
                positionNodesMaxWidth(
                    tree,
                    canvas.width / 2,
                    padding,
                    0,
                    levelHeight
                );
            } else if (layoutStrategy === 'ltr') {
                improvedSquishLTR(tree, canvas.width / 2, padding, 0, levelHeight, cfg);
            } else if (layoutStrategy === 'rtl') {
                improvedSquishRTL(tree, canvas.width / 2, padding, 0, levelHeight, cfg);
            } else if (layoutStrategy === 'contour') {
                positionNodesContour(tree, canvas.width / 2, padding, 0, levelHeight, cfg);
                calculateContours(tree, 0, cfg);
            }
            
            const treeDimensions = calculateTreeDimensions(tree);
            
            const treeWidth = treeDimensions.maxX - treeDimensions.minX + cfg.nodeRadius * 2;
            const treeHeight = treeDimensions.maxY - treeDimensions.minY + cfg.nodeRadius * 2;
            
            const horizontalScale = (canvas.width - padding * 2) / treeWidth;
            const verticalScale = (canvas.height - padding * 2) / treeHeight;
            
            const scale = Math.min(horizontalScale, verticalScale, 1);
            
            const translateX = (canvas.width - treeWidth * scale) / 2 - treeDimensions.minX * scale + cfg.nodeRadius * scale;
            const translateY = (canvas.height - treeHeight * scale) / 2 - treeDimensions.minY * scale + cfg.nodeRadius * scale;
            
            ctx.save();
            ctx.translate(translateX, translateY);
            ctx.scale(scale, scale);
            
            drawNode(ctx, tree, cfg);
            
            ctx.restore();
        }
        
        // Draw all trees
        function drawAllTrees() {
            for (let i = 0; i < trees.length; i++) {
                drawTree(i);
            }
        }
        
        window.onload = drawAllTrees;
        
        window.addEventListener('resize', drawAllTrees);
    </script>
</body>
</html>
